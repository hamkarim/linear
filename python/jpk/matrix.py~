
min_coins_results  = {}
coins = [50, 25, 10, 5, 1]



def min_coins(val, coins):
    global min_coins_results 
    min_coins_results  = {}
    return min_coins_recurse(val, coins, coins)
    
def min_coins_recurse(val, coins, orig_coins):
    if val in orig_coins:
        min_coins_results[val] = 1
    elif val in min_coins_results.keys():
        return min_coins_results[val]
    elif len(coins) == 1: 
        min_coins_results[val] = val
    elif val - coins[0] <0:
        min_coins_results[val] = min_coins_recurse(val, coins[1:], orig_coins)
    else:
        min_coins_results[val] = min(min_coins_recurse(val-coins[0], coins, orig_coins)+1, 
                                     min_coins_recurse(val, coins[1:], orig_coins))
    return min_coins_results[val]
            
class Matrix:
    def __init__(self, m,n, vals):
        self.vals = vals
        self.n = n
        self.m = m
    def row(self, y):
        return self.vals[self.n*y: self.n*(y+1)]
    def rows(self):
        return [self.row(j) for j in range(self.m)]
    def col(self, x):
        return [self.row(y)[x]  for y in range(self.m)]
    def cols(self):
        return [self.col(i) for i in range(self.n)]
    def set_row(self, y, row):
        self.vals[self.n*y: self.n*(y+1)] = row
    def set_col(self, x, col):
        for j in range(self.m):
            self.vals[j*self.n +x] = col[j]
    def elem(self,x,y):
        return self.vals[y*self.n +x]
    def set(self,x,y, value):
        self.vals[y*self.n +x] = value
    def add_row(self, i, new_row):
        '''add a row BEFORE i - ie, if i = 0 then we insert a first row. If self has n rows, 
        then adding at n will add a last row. '''
        self.vals = self.vals[:i*self.n] + new_row + self.vals[i*self.n:]
        self.m +=1
    def add_col(self, j, new_col):
        '''same as add_col: adds before j'''
        self.n +=1
        for i in range(self.m):
            self.vals.insert(i*self.n + j, new_col[i])
    def __repr__(self):
        return "\n".join(["\t".join([str(i) for i in row]) for row in self.rows()])

def mat_from_grid(grid):
    grid = grid.split("\n")
    m = len(grid)
    grid = [row.split() for row in grid]
    n = len(grid[0])
    vals = []
    for row in grid:
        vals.extend([int (i) for i in row])
    return Matrix(m,n,vals)

def tourist(n,m, down, right):
    m+=1
    n+=1
    path = Matrix(m,n, (n)*(m)*[0])
    down = mat_from_grid(down)
    right = mat_from_grid(right)
#    down.add_row(0, m*[0])
#    right.add_col(0, n*[0])
    for i in range(1,m):
        path.set(0, i, path.elem(0,i-1)+down.elem(0,i-1))
    for j in range(1,n):
        path.set(j, 0, path.elem(j-1, 0)+right.elem(j-1,0))
    for col in range(1,n):
        for row in range(1,m):
#            print "prev_row: ",path.elem(col, row-1),  "down cost: " , down.elem(col,row-1)
            path.set(col,row, max(path.elem(col, row-1) + 
                                  down.elem(col, row-1), 
                                  path.elem(col-1,row) + 
                                  right.elem(col-1, row)))
#            print  row,col, path.elem(row, col)
    return path
        


down = '''     1 0 2 4 3
     4 6 5 2 1
     4 4 5 2 1
     5 6 8 5 3'''

d = mat_from_grid(down)

right = '''     3 2 4 0
     3 2 4 2
     0 7 3 3
     3 3 0 2
     1 3 2 2'''
r = mat_from_grid(right)

